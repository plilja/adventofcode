import sys
import re
import heapq
from collections import *


def step1(graph):
    incoming = defaultdict(int)
    for v1 in graph:
        for v2 in graph[v1]:
            incoming[v2] += 1
    pq = []
    for v in graph:
        if incoming[v] == 0:
            heapq.heappush(pq, v)
    res = ''
    while pq:
        v1 = heapq.heappop(pq)
        res += v1
        for v2 in graph[v1]:
            incoming[v2] -= 1
            if incoming[v2] == 0:
                heapq.heappush(pq, v2)
    return res


def step2(graph, workers, step_offset):
    def calc_cost(task):
        return ord(task) - ord('A') + 1 + step_offset

    incoming = defaultdict(int)
    for v1 in graph:
        for v2 in graph[v1]:
            incoming[v2] += 1
    pq = []
    for v in graph:
        if incoming[v] == 0:
            heapq.heappush(pq, (calc_cost(v), v))
    res = ''
    workers = [0 for _ in range(0, workers)]
    time = 0
    while pq:
        v1 = heapq.heappop(pq)
        cost = calc_cost(v1)
        worker = min(workers)
        print(v1, worker, time)
        time += worker
        workers.remove(worker)
        workers = [w - worker for w in workers]
        workers += [cost]
        res += v1
        for v2 in graph[v1]:
            incoming[v2] -= 1
            if incoming[v2] == 0:
                heapq.heappush(pq, v2)
    print(workers)
    time += max(workers)
    return time


def parse_input(inp):
    g = defaultdict(list)
    for s in inp:
        v = s.split()
        a = v[1]
        b = v[7]
        g[a] += [b]
    return g

graph = parse_input(sys.stdin.readlines())
print(step1(graph))
print(step2(graph, 2, 0))
